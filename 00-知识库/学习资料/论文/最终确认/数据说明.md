根据代码告诉我是怎么数据是怎么筛选出来的；让我给数据做一个综合的说明
# 代码1
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
2013–2018 农村户混合截面分析（手写 OLS）
基于：
- 2018 年：chip2018_rural_hh.dta
- 2013 年：SVY_CHIP2013_public.dta
"""

import numpy as np
import pandas as pd
from pathlib import Path


BASE = Path("/Users/sam/Desktop/parrer")


def load_2018():
    """读取并清洗 2018 年农村户数据（户级）"""
    hh_path = BASE / "2018年城乡居民收入分配与生活状况" / "chip2018_rural_hh.dta"
    p_path = BASE / "2018年城乡居民收入分配与生活状况" / "chip2018_rural_p.dta"

    df18_hh = pd.read_stata(hh_path)
    df18_p = pd.read_stata(p_path)

    # 按户聚合劳动投入：B01_3 农忙天数
    labor = (
        df18_p[["hhcode", "B01_3"]]
        .assign(B01_3=lambda d: pd.to_numeric(d["B01_3"], errors="coerce").fillna(0))
        .groupby("hhcode", as_index=False)["B01_3"]
        .sum()
        .rename(columns={"B01_3": "labor"})
    )

    df18 = df18_hh.merge(labor, on="hhcode", how="left")
    df18["labor"] = df18["labor"].fillna(0)

    out = pd.DataFrame()
    out["hhcode"] = df18["hhcode"]
    out["labor"] = df18["labor"]
    # 土地：L01（经营和闲置土地总面积）
    out["land"] = pd.to_numeric(df18.get("L01"), errors="coerce").fillna(0)

    # 农业固定资产：F03_1（农业经营性固定资产现价估计净值）
    asset18 = pd.to_numeric(df18.get("F03_1"), errors="coerce").fillna(0)
    asset18[asset18 < 0] = 0
    out["asset"] = asset18

    # 家庭人口：按个人表统计成员数
    hhsize = (
        df18_p.groupby("hhcode", as_index=False)["idcode"]
        .size()
        .rename(columns={"size": "n_family"})
    )
    out = out.merge(hhsize, left_on="hhcode", right_on="hhcode", how="left")
    out["n_family"] = out["n_family"].fillna(1).astype(float)

    # 数字经济：微信/支付宝有余额
    w1 = pd.to_numeric(df18.get("F01_10"), errors="coerce").fillna(0)
    w2 = pd.to_numeric(df18.get("F01_11"), errors="coerce").fillna(0)
    out["digital"] = ((w1 > 0) | (w2 > 0)).astype(int)

    # 年份与省份
    out["year"] = 2018
    out["province_id"] = df18["hhcode"].astype(str).str[:2]

    return out


def load_2013():
    """读取并清洗 2013 年农村样本（公共文件）"""
    path13 = BASE / "2013年城乡居民收入分配与生活状况" / "SVY_CHIP2013_public.dta"
    df13_raw = pd.read_stata(path13)

    # 按户聚合：劳动/土地/资产取首个
    grp = df13_raw.groupby("hhcode", as_index=False)[["b01_3", "l01_1", "f07_1"]].first()
    # 家庭人口：按个人记录计数
    hhsize = (
        df13_raw.groupby("hhcode", as_index=False)["idcode_a"]
        .size()
        .rename(columns={"size": "n_family"})
    )

    out = pd.DataFrame()
    out["hhcode"] = grp["hhcode"]

    # 劳动：b01_3（2013 农忙天数）
    out["labor"] = pd.to_numeric(grp["b01_3"], errors="coerce").fillna(0)

    # 土地：l01_1（2013 初经营和闲置土地总面积）
    out["land"] = pd.to_numeric(grp["l01_1"], errors="coerce").fillna(0)

    # 农业固定资产：f07_1（2013 年末农业经营性固定资产净值）
    asset13 = pd.to_numeric(grp["f07_1"], errors="coerce").fillna(0)
    asset13[asset13 < 0] = 0
    out["asset"] = asset13

    # 家庭人口
    out = out.merge(hhsize, on="hhcode", how="left")
    out["n_family"] = out["n_family"].fillna(1).astype(float)

    # 数字经济：2013 视作前移动支付时代，统一为 0
    out["digital"] = 0

    # 年份与省份
    out["year"] = 2013
    out["province_id"] = out["hhcode"].astype(str).str[:2]

    return out


def build_panel():
    df18 = load_2018()
    df13 = load_2013()

    df = pd.concat([df18, df13], ignore_index=True)

    # 仅保留有劳动和土地的“真农户”
    df = df[(df["labor"] > 0) & (df["land"] > 0)].copy()

    # 对数化
    df["ln_labor"] = np.log(df["labor"] + 1.0)
    df["ln_land"] = np.log(df["land"] + 1.0)
    df["ln_asset"] = np.log(df["asset"] + 1.0)
    df["ln_n"] = np.log(df["n_family"].astype(float))

    # 年份虚拟变量
    df["y2018"] = (df["year"] == 2018).astype(int)

    # 交互项：人口 × 数字经济
    df["ln_n_x_dig"] = df["ln_n"] * df["digital"]

    # 去除 log 产生的 NaN/inf
    df = df.replace([np.inf, -np.inf], np.nan)
    df = df.dropna(subset=["ln_labor", "ln_land", "ln_asset", "ln_n"])

    return df


def ols_with_dummies(y, X_base, base_names, df, add_province=True):
    """简单 OLS：X_base + 省份虚拟变量，带自定义变量名"""
    if add_province:
        prov_dummies = pd.get_dummies(df["province_id"], prefix="prov", drop_first=True)
        X_prov = prov_dummies.to_numpy(dtype=float)
    else:
        prov_dummies = pd.DataFrame(index=df.index)
        X_prov = np.empty((len(df), 0))

    X = np.column_stack([X_base, X_prov])
    X = np.column_stack([np.ones(len(X)), X])

    XtX_inv = np.linalg.inv(X.T @ X)
    beta = XtX_inv @ (X.T @ y)

    y_hat = X @ beta
    resid = y - y_hat
    n, k = X.shape
    sigma2 = (resid @ resid) / (n - k)
    var_beta = sigma2 * XtX_inv
    se_beta = np.sqrt(np.diag(var_beta))
    t_beta = beta / se_beta

    r2 = 1 - (resid @ resid) / ((y - y.mean()) @ (y - y.mean()))

    names = ["const"] + list(base_names) + list(prov_dummies.columns)
    return beta, se_beta, t_beta, r2, names


def run_panel_models():
    df = build_panel()

    print(f"混合样本总数: {len(df)}")
    print("年份分布:\n", df["year"].value_counts())

    # 模型一：资本投入 ln_asset ~ digital + y2018 + ln_land + ln_n + 省份
    print("\n" + "=" * 60)
    print("【模型一 (Panel)】：数字经济对农业资本投入的影响 (ln_asset)")
    print("=" * 60)

    X1_base = df[["digital", "y2018", "ln_land", "ln_n"]].to_numpy(dtype=float)
    names1_base = ["digital", "y2018", "ln_land", "ln_n"]
    y1 = df["ln_asset"].to_numpy(dtype=float)
    beta1, se1, t1, r21, names1 = ols_with_dummies(y1, X1_base, names1_base, df)

    print(f"R2: {r21:.3f}")
    print("\ncoef\tstd_err\tt-value\tvariable")
    for name, b, se, t in zip(names1, beta1, se1, t1):
        print(f"{b: .4f}\t{se: .4f}\t{t: .2f}\t{name}")

    # 模型二：劳动可分性 ln_labor ~ ln_n + digital + ln_n_x_dig + y2018 + ln_land + ln_asset + 省份
    print("\n" + "=" * 60)
    print("【模型二 (Panel)】：劳动可分性的动态检验 (ln_labor)")
    print("=" * 60)

    X2_base = df[["ln_n", "digital", "ln_n_x_dig", "y2018", "ln_land", "ln_asset"]].to_numpy(dtype=float)
    names2_base = ["ln_n", "digital", "ln_n_x_dig", "y2018", "ln_land", "ln_asset"]
    y2 = df["ln_labor"].to_numpy(dtype=float)
    beta2, se2, t2, r22, names2 = ols_with_dummies(y2, X2_base, names2_base, df)

    print(f"R2: {r22:.3f}")
    print("\ncoef\tstd_err\tt-value\tvariable")
    for name, b, se, t in zip(names2, beta2, se2, t2):
        print(f"{b: .4f}\t{se: .4f}\t{t: .2f}\t{name}")


def main():
    run_panel_models()


if __name__ == "__main__":
    main()

#代码2
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
2018 年农村住户：劳动投入与数字经济可分性检验
使用 chip2018_rural_hh.dta 与 chip2018_rural_p.dta
"""

import numpy as np
import pandas as pd
from pathlib import Path


BASE = Path("/Users/sam/Desktop/parrer")


def build_2018_rural_df() -> pd.DataFrame:
    """构造 2018 年农村住户分析用数据集"""
    # 户级数据
    hh_path = BASE / "2018年城乡居民收入分配与生活状况" / "chip2018_rural_hh.dta"
    hh = pd.read_stata(hh_path, convert_categoricals=False)

    # 个体级数据
    p_path = BASE / "2018年城乡居民收入分配与生活状况" / "chip2018_rural_p.dta"
    p = pd.read_stata(p_path, convert_categoricals=False)

    # 年份（用于计算年龄）
    survey_year = 2018

    # 1. 家庭农业劳动投入：按户汇总 B01_3（2018 年农忙天数）
    labor = (
        p[["hhcode", "B01_3"]]
        .assign(B01_3=lambda d: d["B01_3"].fillna(0))
        .groupby("hhcode", as_index=False)["B01_3"]
        .sum()
        .rename(columns={"B01_3": "labor_days"})
    )

    # 2. 家庭人口：优先使用户级 nhh（与个人表人数一致）
    # 数据概览中已给出 nhh 字段
    if "nhh" in hh.columns:
        hh["hhsize"] = hh["nhh"].astype(float)
    else:
        hhsize = (
            p.groupby("hhcode", as_index=False)["idcode"]
            .size()
            .rename(columns={"size": "hhsize"})
        )
        hh = hh.merge(hhsize, on="hhcode", how="left")

    # 3. 户主特征与抚养比
    #   - 户主：A02==1
    #   - 教育：A13_3 受正规教育年数
    #   - 年龄：survey_year - A04_1
    heads = p.loc[p["A02"] == 1, ["hhcode", "A13_3", "A04_1"]].copy()
    heads["edu_years"] = heads["A13_3"]
    heads["head_age"] = survey_year - heads["A04_1"]
    heads = heads[["hhcode", "edu_years", "head_age"]]

    # 抚养人口（<15 或 >64 岁）
    p["age"] = survey_year - p["A04_1"]
    p["is_dependent"] = ((p["age"] < 15) | (p["age"] > 64)).astype(int)
    dep = (
        p.groupby("hhcode", as_index=False)["is_dependent"]
        .sum()
        .rename(columns={"is_dependent": "num_dependent"})
    )

    # 合并到户级数据
    df = (
        hh.merge(labor, on="hhcode", how="left")
        .merge(dep, on="hhcode", how="left")
        .merge(heads, on="hhcode", how="left")
    )

    # 4. 土地变量：L01 = 2018 年经营和闲置土地总面积（亩）
    if "L01" in df.columns:
        df["land"] = df["L01"]
    else:
        df["land"] = np.nan

    # 农业固定资产与役畜资产：F03_1、F07
    for col in ("F03_1", "F07"):
        if col not in df.columns:
            df[col] = 0
    df["asset_val"] = pd.to_numeric(df["F03_1"], errors="coerce").fillna(0)
    df["livestock_val"] = pd.to_numeric(df["F07"], errors="coerce").fillna(0)
    df.loc[df["asset_val"] < 0, "asset_val"] = 0
    df.loc[df["livestock_val"] < 0, "livestock_val"] = 0

    # 5. 数字经济变量：F01_10 微信钱包，F01_11 支付宝余额
    # 只要任一余额 > 0 视为使用数字金融工具
    for col in ("F01_10", "F01_11"):
        if col not in df.columns:
            df[col] = 0

    df["digital"] = 0
    df.loc[(df["F01_10"] > 0) | (df["F01_11"] > 0), "digital"] = 1

    # 补充缺失为 0 的抚养人口
    df["num_dependent"] = df["num_dependent"].fillna(0)

    # 6. 丢弃关键变量缺失或异常值
    df = df.dropna(subset=["labor_days", "hhsize", "edu_years", "head_age"])

    # 剔除不种地或无土地的户
    df = df[(df["labor_days"] > 0) & (df["hhsize"] > 0)]
    df = df[df["land"] > 0]

    # 对劳动投入做简单缩尾（上 1% 截断）
    q99 = df["labor_days"].quantile(0.99)
    df.loc[df["labor_days"] > q99, "labor_days"] = q99

    # 7. 构造派生变量：对数与交互项
    df["log_L"] = np.log(df["labor_days"])
    df["log_n"] = np.log(df["hhsize"].astype(float))
    df["log_n_dig"] = df["log_n"] * df["digital"]

    # 对数土地
    df["ln_land"] = np.log(df["land"])

    # 抚养比
    df["dep_ratio"] = df["num_dependent"] / df["hhsize"]

    # 资本要素：农业固定资产与役畜，对数形式
    df["ln_asset"] = np.log(df["asset_val"] + 1.0)
    df["ln_livestock"] = np.log(df["livestock_val"] + 1.0)

    # 户主年龄平方（/100）
    df["head_age_sq"] = (df["head_age"] ** 2) / 100.0

    # 从 hhcode 提取省份代码（前两位）
    df["hhcode_str"] = df["hhcode"].astype(str)
    df["province_id"] = df["hhcode_str"].str[:2].astype(int)

    return df


def run_2018_models():
    """运行 2018 年资本模型与可分性检验回归（手写 OLS）"""
    df = build_2018_rural_df()

    print(f"样本量: {len(df)}")
    print(f"数字经济渗透率(digital=1比例): {df['digital'].mean():.3f}")

    # 省份虚拟变量（去掉一个基准省）
    prov_dummies = pd.get_dummies(df["province_id"], prefix="prov", drop_first=True)
    X_prov = prov_dummies.to_numpy(dtype=float)

    # ---------- 模型一：资本投入（ln_asset） ----------
    cap_base_cols = [
        "digital",
        "ln_land",
        "log_n",
        "edu_years",
        "head_age",
        "dep_ratio",
    ]
    X_cap_base = df[cap_base_cols].to_numpy(dtype=float)
    X_cap = np.column_stack([X_cap_base, X_prov])
    y_cap = df["ln_asset"].to_numpy(dtype=float)
    X_cap = np.column_stack([np.ones(len(X_cap)), X_cap])

    XtX_inv_cap = np.linalg.inv(X_cap.T @ X_cap)
    beta_cap = XtX_inv_cap @ (X_cap.T @ y_cap)
    y_cap_hat = X_cap @ beta_cap
    resid_cap = y_cap - y_cap_hat
    n_cap, k_cap = X_cap.shape
    sigma2_cap = (resid_cap @ resid_cap) / (n_cap - k_cap)
    var_beta_cap = sigma2_cap * XtX_inv_cap
    se_beta_cap = np.sqrt(np.diag(var_beta_cap))
    t_beta_cap = beta_cap / se_beta_cap

    names_cap = ["const"] + cap_base_cols + prov_dummies.columns.tolist()

    print("\n=== 模型一：数字经济对农业固定资产投资的影响（OLS） ===")
    r2_cap = 1 - (resid_cap @ resid_cap) / ((y_cap - y_cap.mean()) @ (y_cap - y_cap.mean()))
    print(f"R2: {r2_cap:.3f}")
    print("\ncoef\tstd_err\tt-value\tvariable")
    for name, b, se, t in zip(names_cap, beta_cap, se_beta_cap, t_beta_cap):
        print(f"{b: .4f}\t{se: .4f}\t{t: .2f}\t{name}")

    # ---------- 模型二：劳动投入可分性（ln_labor） ----------
    lab_base_cols = [
        "log_n",
        "digital",
        "log_n_dig",
        "ln_land",
        "ln_asset",
        "ln_livestock",
        "dep_ratio",
        "head_age",
        "head_age_sq",
        "edu_years",
    ]
    X_lab_base = df[lab_base_cols].to_numpy(dtype=float)
    X_lab = np.column_stack([X_lab_base, X_prov])
    y_lab = df["log_L"].to_numpy(dtype=float)
    X_lab = np.column_stack([np.ones(len(X_lab)), X_lab])

    XtX_inv_lab = np.linalg.inv(X_lab.T @ X_lab)
    beta_lab = XtX_inv_lab @ (X_lab.T @ y_lab)
    y_lab_hat = X_lab @ beta_lab
    resid_lab = y_lab - y_lab_hat
    n_lab, k_lab = X_lab.shape
    sigma2_lab = (resid_lab @ resid_lab) / (n_lab - k_lab)
    var_beta_lab = sigma2_lab * XtX_inv_lab
    se_beta_lab = np.sqrt(np.diag(var_beta_lab))
    t_beta_lab = beta_lab / se_beta_lab

    names_lab = ["const"] + lab_base_cols + prov_dummies.columns.tolist()

    print("\n=== 模型二：控制资本后的劳动可分性检验（OLS） ===")
    r2_lab = 1 - (resid_lab @ resid_lab) / ((y_lab - y_lab.mean()) @ (y_lab - y_lab.mean()))
    print(f"R2: {r2_lab:.3f}")
    print("\ncoef\tstd_err\tt-value\tvariable")
    for name, b, se, t in zip(names_lab, beta_lab, se_beta_lab, t_beta_lab):
        print(f"{b: .4f}\t{se: .4f}\t{t: .2f}\t{name}")

    return df, {
        "capital": dict(beta=beta_cap, se=se_beta_cap, t=t_beta_cap, names=names_cap),
        "labor": dict(beta=beta_lab, se=se_beta_lab, t=t_beta_lab, names=names_lab),
    }


def main():
    run_2018_models()


if __name__ == "__main__":
    main()

# 数据
# 数据

### 第一部分：基于 CHIP 2018 的截面分析
**数据基础：** 2018 年农村户数据，样本量 **2,611 户**。

#### 1. 模型一：数字经济对农业资本投入的影响 (H1)
*   **回归方程：** $ln\_asset \sim digital + controls$
*   **关键数据：**
    *   **$Digital$ (系数)：** **0.5336** (t = 3.22, p < 0.01)
*   **研究结论：**
    *   数字经济**显著促进**了农户的农业固定资产投资（如农机、设施）。
    *   系数表明，在同等条件下，接入数字经济的农户比未接入农户的资本投入高出约 53%。这验证了数字技术通过降低信息成本，推动了农业生产从“劳动密集”向“资本密集”转型。

#### 2. 模型二：农户生产决策的可分性检验 (H2)
*   **回归方程：** $ln\_labor \sim ln\_n + digital + ln\_n \times digital + ln\_asset + controls$
*   **关键数据：**
    *   **$ln\_n$ (家庭人口系数)：** **0.1769** (t = 2.14, p < 0.05) —— **显著为正**。
    *   **$ln\_asset$ (资本投入系数)：** **0.0326** (t = 4.73, p < 0.01) —— **显著为正**。
    *   **$Interaction$ (交互项系数)：** **不显著**。
*   **研究结论：**
    *   **不可分性验证：** 家庭人口规模依然显著正向影响劳动投入，印证了 Benjamin (1992) 关于中国农户“生产-消费不可分”的经典假设。
    *   **转型滞后：** 交互项不显著说明，在 2018 年，虽然农户买了更多机器（资本增加了），但尚未从根本上打破家庭人口对劳动供给的束缚，数字经济对劳动配置模式的重塑存在滞后性。

---

### 第二部分：基于 CHIP 2013-2018 的混合截面分析
**数据基础：** 2013 与 2018 年合并数据，样本量 **9,735 户**。

#### 1. 模型一：资本深化的动态检验 (H1 增强版)
*   **回归方程：** $ln\_asset \sim digital + y2018 + controls$
*   **关键数据：**
    *   **$Digital$ (系数)：** **0.6258** (t = 3.94, p < 0.01)
    *   **$y2018$ (时间效应)：** **-0.2349** (t = -2.17)
*   **研究结论：**
    *   在控制了时间趋势和土地规模后，数字经济对资本积累的促进作用**依然稳健且显著**。
    *   这排除了“随时间自然增长”的解释，有力证明了数字红利是推动农户进行硬件投资、实现农业现代化的关键动力。

#### 2. 模型二：劳动配置逻辑的动态演变 (H2 深度版)
*   **回归方程：** $ln\_labor \sim ln\_n + digital + ln\_n \times digital + y2018 + controls$
*   **关键数据：**
    *   **$Digital$ (主效应)：** **-0.2276** (t = -2.11, p < 0.05) —— **显著为负**。
    *   **$Interaction$ (交互项系数)：** **0.1708** (t = 2.00, p < 0.05) —— **显著为正**。
    *   **$y2018$ (时间效应)：** **0.5114** (t = 18.57) —— **显著为正**。
*   **研究结论：**
    *   **技术替代效应：** Digital 主效应为负，说明数字经济整体上**减少**了农业劳动投入（机器换人效应显现）。
    *   **家庭协同增强效应（交互项为正）：** 对于数字化农户，家庭人口对劳动的束缚反而**更强**。这表明数字农业（如精细化种植、电商运营）虽然减少了纯体力劳动，但创造了新的、需要家庭成员紧密协作的劳动需求。数字经济没有简单地让农户“解绑”，而是让家庭内部的劳动分工变得更加紧密和重要。

---

### 总结论 (Executive Summary)

你的研究发现：**数字经济显著推动了中国农户的“硬件转型”（资本深化），但在“软件转型”（劳动配置）上呈现出复杂的双重特征——既通过机械化替代了部分传统体力劳动，又通过新业态强化了家庭内部的协同劳动机制。**
